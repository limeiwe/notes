# 深入理解递归

​		我们再写程序时经常会使用递归函数来解决问题，但是对于很多人来说，递归是比较难以理解的，或者说，很多人对于递归的理解是不够深入的，而如果在对递归的理解不深入的情况下就贸然地使用递归的话，往往就会使我们程序出现各种意想不到bug，而且往往也难以排错。而且有很多经典地算法也涉及到递归。因此深入理解递归对我们IT人员来说至关重要，本篇博客将会详细地讲解关于递归的内容。

​		**首先**是关于递归的**定义**:在编程语言中，我们将调用自身的函数称作递归函数，即定义一个函数，在这个函数的可执行代码中再调用自己本身函数。

​		**其次**，也是最重要的，关于递归函数的**基本原理**:递归函数是用栈结构来实现的，递归的整个过程就是一个入栈和出栈的过程，当程序执行一个函数时就会创建一个新的受保护的独立空间(新函数栈)。在递归函数执行时，由上一层进入下一层函数时，上一层会暂停执行，并且会暂停局部变量的值、寄存器中保存的数据等，各层之间的局部变量是相互独立、互不影响的。

​		**然后**，关于递归的几个**基本规则**：1.递归函数必须设置函数出口(结束条件)，并且函数的执行方向必须朝着满足出口条件的方向进行，否则就会无限递归，造成栈溢出。2.当下一层的函数执行完毕后上一层的函数才会执行，所以只有当最后一层函数执行完毕后，每层函数才会由内向外依次执行，当最外层函数执行完毕后，整个递归函数才算执行完毕。

​		**接下来**，用几个具体的例子来理解递归：

1.求n!

```python
def fn(n):
    if n ==1 or n == 0:
        return 1
    else:
        return n*fn(n-1)

print(fn(5))
#120
```

这个函数的执行情况如图

![](img\02.jpg)

上面的题很简单，下面用一个较为复杂的题

2.回路计数问题：

<img src="img\03.jpg" style="margin-left:0;" />

下面用递归的方式来解这道题，算然该方法并不是最优解，但是通过追踪步骤可以让我们更加清晰地认识递归。

```python
import math
import sys
sys.setrecursionlimit(10000)
n = int(input())
li = [i for i in range(2, n + 1)]
def dfs(li, li_tmp):
    global count
    if len(li_tmp) == len(li):
        count += 1
        return
    for j in range(len(li)):
        tmp = li_tmp[:]  # 进行浅拷贝，不然后面回不去
        if li[j] not in li_tmp and math.gcd(li_tmp[-1], li[j]) == 1:
            li_tmp.append(li[j])
            dfs(li, li_tmp)
            li_tmp = tmp[:]
count = 0
for i in range(len(li)):
    li_tmp = [li[i]]
    dfs(li, li_tmp)
print(count)
```

我们以n=5为例，分析当li_tmp = li[0] 即li = [2]时，函数的递归过程

下面是调试的具体过程：

![](img\04.gif)6

​		一开始，当li = [2,3,4,5]和li_tmp = [2]传进去时,会先进行if判断，注意已经执行完的部分在以后的递归中不会再执行，因为上一层代码再次执行是执行后面没有执行完的代码，执行完if判断之后进入for循环，当遍历到的值满足条件时，就会进入下一层函数，这里要注意的是如果此时的for循环没有执行完，那么当从内向外再次返回执行时，就会接着后面的内容执行，没有执行完的循环也会再次执行，直到循环结束。就这样一层一层地执行，直到li_tmp = [2,3,4,5]，最后一层函数判断if len(li_tmp) == len(li) 满足条件，执行return，函数执行完毕，这时候，函数就会返回到上一层，而上一层函数n=3,for循环内执行到的dfs(li, li_tmp)执行完毕，此时li_tmp = [2,3,4,5]，然后接着向下走li_tmp = tmp[:]，li_tmp变为[2,3,4]，然后返回到for循环顶部，发现不满足条件退出循环，然后要知道，在这一层li_tmp = [2,3,4,5],所以li_tmp 又变为了[2,3,4,5]，上面我们说过上层函数暂停时会暂停局部变量的值、寄存器中保存的数据等，各层之间互不影响。至此，上层函数执行完毕，然后再进入上上层，因为上上层的i=2，它的for循环还没有到头，所以它会再次进行for循环，并执行for循环里面的代码，从而再次进行递归。。。。后面的内容就大同小异了。

​		通过分析上诉例子，我们可以得知，当上层函数暂停执行时，函数内部的变量会保存当时的值，而且其中的控制语句如for循环等也会暂停执行等待回归重启。



